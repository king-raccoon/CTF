> Why is everyone so obsessed with multiplying two primes for RSA. Why not just use one?

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591  
<br>e = 65537
<br>ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

[Why do we need in RSA the modulus to be product of 2 primes?](https://crypto.stackexchange.com/questions/5170/why-do-we-need-in-rsa-the-modulus-to-be-product-of-2-primes)

1. 만약 n가 두 소수 p, q의 곱이 아닌 어떤 큰 소수라면?
2. 만약 n이 랜덤한 합성수라면?

⇒ n을 인수분해 할 수 있다면 개인키를 알아내기 쉬워진다

```python
n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

d = pow(e, -1, n-1)
print(hex(pow(ct, d, n)))

str = "63727970746f7b306e335f7072316d335f34316e375f7072316d335f6c306c7d"
print(bytearray.fromhex(str))
```

`crypto{0n3_pr1m3_41n7_pr1m3_l0l}`

cf)
[Python에서 16 진수를 ASCII로 변환](https://www.delftstack.com/ko/howto/python/hex-to-ascii-python/)
